// Generated by CoffeeScript 1.9.1
(function() {
  var assert, async, call, describe, fs, ref, ref1,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require("./generator"), call = ref.call, async = ref.async;

  fs = function(f) {
    var liftAll;
    liftAll = require("when/node").liftAll;
    return f(liftAll(require("fs")), {
      call: call,
      async: async
    });
  };

  ref1 = require("./helpers"), describe = ref1.describe, assert = ref1.assert;

  describe("File system functions", function(context) {
    var binary, chdir, curry, dirname, exist, exists, is_directory, is_file, lines, mkdir, mkdirp, read, read_stream, readdir, ref2, rm, rmdir, stat, stream, write;
    stat = function(path) {
      return fs(function(arg) {
        var stat;
        stat = arg.stat;
        return stat(path);
      });
    };
    context.test("stat", function*() {
      return assert(((yield stat("test/test.json"))).size != null);
    });
    exists = exist = function(path) {
      return fs(function(arg) {
        var stat;
        stat = arg.stat;
        return call(function*() {
          try {
            (yield stat(path));
            return true;
          } catch (_error) {
            return false;
          }
        });
      });
    };
    context.test("exists", function*() {
      assert((yield exists("test/test.json")));
      return assert(!((yield exists("test/does-not-exist"))));
    });
    read = function(path) {
      return fs(function(arg, arg1) {
        var call, readFile;
        readFile = arg.readFile;
        call = arg1.call;
        return call(function*() {
          return ((yield readFile(path))).toString();
        });
      });
    };
    context.test("read", function*() {
      return assert((JSON.parse((yield read("test/test.json")))).name === "fairmont");
    });
    readdir = function(path) {
      return fs(function(arg) {
        var readdir;
        readdir = arg.readdir;
        return readdir(path);
      });
    };
    context.test("readdir", function*() {
      return assert(indexOf.call((yield readdir("test")), "test.json") >= 0);
    });
    read_stream = function(stream) {
      var buffer, promise;
      promise = require("when").promise;
      buffer = "";
      return promise(function(resolve, reject) {
        stream.on("data", function(data) {
          return buffer += data.toString();
        });
        stream.on("end", function() {
          return resolve(buffer);
        });
        return stream.on("error", function(error) {
          return reject(error);
        });
      });
    };
    context.test("read_stream", function() {
      return (function*(lines) {
        var Readable, promise, s;
        Readable = require("stream").Readable;
        s = new Readable;
        promise = read(s);
        s.push("one\n");
        s.push("two\n");
        s.push("three\n");
        s.push(null);
        lines = ((yield promise)).split("\n");
        assert(lines.length === 3);
        return assert(lines[0] === "one");
      })(lines);
    });
    lines = function(stream) {
      return (require("byline"))(stream);
    };
    stream = (function(arg) {
      var promise, reject, resolve;
      promise = arg.promise, reject = arg.reject, resolve = arg.resolve;
      return function(s) {
        return (function(pending, resolved, _resolve, _reject) {
          _resolve = function(x) {
            if (pending.length === 0) {
              return resolved.push(resolve(x));
            } else {
              return pending.shift().resolve(x);
            }
          };
          _reject = function(x) {
            if (pending.length === 0) {
              return resolved.push(reject(x));
            } else {
              return pending.shift().reject(x);
            }
          };
          s.on("data", function(data) {
            return _resolve(data.toString());
          });
          s.on("end", function() {
            return _resolve(null);
          });
          s.on("error", function() {
            return _reject(error);
          });
          return function() {
            if (resolved.length === 0) {
              return promise(function(resolve, reject) {
                return pending.push({
                  resolve: resolve,
                  reject: reject
                });
              });
            } else {
              return resolved.shift();
            }
          };
        })([], [], null, null);
      };
    })(require("when"));
    context.test("stream", function*() {
      var Readable, _s, s;
      Readable = require("stream").Readable;
      s = new Readable;
      _s = stream(lines(s));
      s.push("one\n");
      s.push("two\n");
      s.push("three\n");
      s.push(null);
      assert(((yield _s())) === "one");
      assert(((yield _s())) === "two");
      return assert(((yield _s())) === "three");
    });
    write = function(path, content) {
      return fs(function(arg) {
        var writeFile;
        writeFile = arg.writeFile;
        return writeFile(path, content);
      });
    };
    context.test("write", function*() {
      return write("test/test.json", (yield read("test/test.json")));
    });
    chdir = function(dir, fn) {
      return fs(function*(arg, arg1) {
        var async, cwd, rval;
        arg;
        async = arg1.async;
        cwd = process.cwd();
        process.chdir(dir);
        rval = (yield fn());
        process.chdir(cwd);
        return rval;
      });
    };
    fs(function(arg, arg1) {
      var async;
      arg;
      async = arg1.async;
      return context.test("chdir", function*() {
        (yield chdir("test", async(function*() {
          return assert((yield exists("test.json")));
        })));
        return assert((process.cwd().match(/test$/)) == null);
      });
    });
    rm = function(path) {
      return fs(function(arg) {
        var unlink;
        unlink = arg.unlink;
        return unlink(path);
      });
    };
    context.test("rm");
    rmdir = function(path) {
      return fs(function(arg) {
        var rmdir;
        rmdir = arg.rmdir;
        return rmdir(path);
      });
    };
    context.test("rmdir", function() {});
    is_directory = function(path) {
      return fs(function(arg, arg1) {
        var call, stat;
        stat = arg.stat;
        call = arg1.call;
        return call(function*() {
          return ((yield stat(path))).isDirectory();
        });
      });
    };
    context.test("is_directory", function*() {
      return assert((yield is_directory("./test")));
    });
    is_file = function(path) {
      return fs(function(arg, arg1) {
        var call, stat;
        stat = arg.stat;
        call = arg1.call;
        return call(function*() {
          return ((yield stat(path))).isFile();
        });
      });
    };
    context.test("is_file", function*() {
      return assert((yield is_file("./test/test.json")));
    });
    ref2 = require("./core"), curry = ref2.curry, binary = ref2.binary;
    mkdir = curry(function(mode, path) {
      return fs(function(arg) {
        var mkdir;
        mkdir = arg.mkdir;
        return mkdir(path, mode);
      });
    });
    context.test("mdkir", function*() {
      (yield mkdir('0777', "./test/foobar"));
      assert((yield is_directory("./test/foobar")));
      return (yield rmdir("./test/foobar"));
    });
    dirname = require("path").dirname;
    mkdirp = curry(binary(async(function*(mode, path) {
      var parent;
      parent = dirname(path);
      if (!((yield exists(parent)))) {
        (yield mkdirp(mode, parent));
      }
      return mkdir(mode, path);
    })));
    context.test("mkdirp", function*() {
      (yield mkdirp('0777', "./test/foo/bar"));
      assert((yield is_directory("./test/foo/bar")));
      (yield rmdir("./test/foo/bar"));
      return (yield rmdir("./test/foo"));
    });
    return module.exports = {
      read: read,
      write: write,
      stream: stream,
      lines: lines,
      rm: rm,
      stat: stat,
      exist: exist,
      exists: exists,
      is_file: is_file,
      is_directory: is_directory,
      readdir: readdir,
      mkdir: mkdir,
      mkdirp: mkdirp,
      chdir: chdir,
      rmdir: rmdir
    };
  });

}).call(this);
