// Generated by CoffeeScript 1.9.1
(function() {
  var _, assert, binary, compose, curry, deep_equal, describe, detach, flip, identity, lt, odd, partial, ref, ref1, ref2, ternary, unary,
    slice1 = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require("./core"), curry = ref.curry, flip = ref.flip, compose = ref.compose, partial = ref.partial, _ = ref._, identity = ref.identity, unary = ref.unary, binary = ref.binary, ternary = ref.ternary;

  detach = require("./object").detach;

  deep_equal = require("./type").deep_equal;

  ref1 = require("./numeric"), odd = ref1.odd, lt = ref1.lt;

  ref2 = require("./helpers"), assert = ref2.assert, describe = ref2.describe;

  describe("Array functions", function(context) {
    var cat, difference, dupes, empty, first, includes, intersection, last, range, remove, rest, second, shuffle, slice, third, union, uniq, unique, unique_by;
    empty = function(ax) {
      return ax.length === 0;
    };
    cat = detach(Array.prototype.concat);
    context.test("cat", function() {
      var data;
      data = [1, 2, 3, 4, 5];
      assert(deep_equal(cat(data), data));
      return assert(deep_equal(cat(data, data), data.concat(data)));
    });
    slice = curry(function(i, j, ax) {
      return ax.slice(i, j);
    });
    context.test("slice", function() {
      var data;
      data = [1, 2, 3, 4, 5];
      return assert(deep_equal((slice(1, 2))(data), [2]));
    });
    first = function(ax) {
      return ax[0];
    };
    context.test("first", function() {
      var data;
      data = [1, 2, 3, 4, 5];
      return assert((first(data)) === 1);
    });
    second = function(ax) {
      return ax[1];
    };
    third = function(ax) {
      return ax[2];
    };
    last = function(arg) {
      var k, rest, x;
      rest = 2 <= arg.length ? slice1.call(arg, 0, k = arg.length - 1) : (k = 0, []), x = arg[k++];
      return x;
    };
    context.test("last", function() {
      return (function(data) {
        return assert((last(data)) === 5);
      })([1, 2, 3, 4, 5]);
    });
    rest = slice(1, void 0);
    context.test("rest", function() {
      return (function(data) {
        return assert(deep_equal(rest(data), [2, 3, 4, 5]));
      })([1, 2, 3, 4, 5]);
    });
    includes = curry(function(x, ax) {
      return indexOf.call(ax, x) >= 0;
    });
    context.test("includes", function() {
      return (function(data) {
        assert(includes(3, data));
        return assert(!(includes(6, data)));
      })([1, 2, 3, 4, 5]);
    });
    unique_by = curry(function(f, ax) {
      var a, b, bx, k, len;
      bx = [];
      for (k = 0, len = ax.length; k < len; k++) {
        a = ax[k];
        b = f(a);
        if (indexOf.call(bx, b) < 0) {
          bx.push(b);
        }
      }
      return bx;
    });
    unique = uniq = unique_by(identity);
    context.test("unique", function() {
      return assert(deep_equal(unique(cat([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5])), [1, 2, 3, 4, 5]));
    });
    dupes = function(arg) {
      var a, ax, bx;
      a = arg[0], ax = 2 <= arg.length ? slice1.call(arg, 1) : [];
      if (empty(ax)) {
        return [];
      } else {
        bx = dupes(ax);
        if (indexOf.call(ax, a) >= 0 && !(indexOf.call(bx, a) >= 0)) {
          return [a].concat(slice1.call(bx));
        } else {
          return bx;
        }
      }
    };
    context.test("dupes", function() {
      return assert(deep_equal(dupes(cat([1, 2, 3], [2, 3, 4], [3, 4, 5])), [2, 3, 4]));
    });
    union = curry(compose(unique, cat));
    context.test("union", function() {
      return (function(a, b) {
        assert(deep_equal(union(a, b), [1, 2, 3, 4, 5, 6]));
        return assert(deep_equal(union(a, a), [1, 2, 3, 4]));
      })([1, 2, 3, 4], [3, 4, 5, 6]);
    });
    intersection = function() {
      var first, k, len, ref3, rest, results, x;
      first = arguments[0], rest = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
      if (empty(rest)) {
        return first;
      } else {
        ref3 = intersection.apply(null, rest);
        results = [];
        for (k = 0, len = ref3.length; k < len; k++) {
          x = ref3[k];
          if (indexOf.call(first, x) >= 0) {
            results.push(x);
          }
        }
        return results;
      }
    };
    context.test("intersection", function() {
      assert(empty(intersection([1, 2], [3, 4])));
      assert(empty(intersection([1, 1], [2, 2])));
      assert(empty(intersection([], [1, 2, 3])));
      assert(empty(intersection([1, 2, 3], [])));
      assert(empty(intersection([1, 2], [2, 3], [3, 4])));
      assert((first(intersection([1, 2], [2, 3]))) === 2);
      return assert((first(intersection([1, 2], [2, 3], [3, 2]))) === 2);
    });
    difference = curry(function(ax, bx) {
      var cx;
      cx = union(ax, bx);
      return cx.filter(function(c) {
        return (indexOf.call(ax, c) >= 0 && !(indexOf.call(bx, c) >= 0)) || (indexOf.call(bx, c) >= 0 && !(indexOf.call(ax, c) >= 0));
      });
    });
    context.test("difference", function() {
      return (function(ax, bx) {
        return assert(deep_equal(difference(ax, bx), [1, 2, 5, 6]));
      })([1, 2, 3, 4], [3, 4, 5, 6]);
    });
    remove = function(array, element) {
      var index, ref3;
      if ((index = array.indexOf(element)) > -1) {
        [].splice.apply(array, [index, index - index + 1].concat(ref3 = [])), ref3;
        return element;
      } else {
        return null;
      }
    };
    shuffle = function(ax) {
      var b, bx, i, j, k, len, ref3;
      bx = cat(ax);
      if (!(bx.length <= 1)) {
        for (i = k = 0, len = bx.length; k < len; i = ++k) {
          b = bx[i];
          j = i;
          while (j === i) {
            j = Math.floor(Math.random() * bx.length);
          }
          ref3 = [bx[j], bx[i]], bx[i] = ref3[0], bx[j] = ref3[1];
        }
        if (deep_equal(ax, bx)) {
          return shuffle(ax);
        } else {
          return bx;
        }
      } else {
        return bx;
      }
    };
    context.test("shuffle", function() {
      return (function(data) {
        return assert(!deep_equal(shuffle(data), data));
      })([1, 2, 3, 4, 5]);
    });
    range = function(start, finish) {
      var k, results;
      return (function() {
        results = [];
        for (var k = start; start <= finish ? k <= finish : k >= finish; start <= finish ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this);
    };
    context.test("range", function() {
      return assert(deep_equal(range(1, 5), [1, 2, 3, 4, 5]));
    });
    return module.exports = {
      cat: cat,
      slice: slice,
      empty: empty,
      first: first,
      second: second,
      third: third,
      last: last,
      rest: rest,
      includes: includes,
      unique_by: unique_by,
      unique: unique,
      uniq: uniq,
      dupes: dupes,
      union: union,
      intersection: intersection,
      difference: difference,
      remove: remove,
      shuffle: shuffle
    };
  });

}).call(this);
