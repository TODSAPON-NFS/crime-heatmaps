// Generated by CoffeeScript 1.8.0
(function() {
  var counter, parse_url, promise, read, redirects, request, resolve, schemes, type, user_agent, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  resolve = require("path").resolve;

  parse_url = (require("url")).parse;

  promise = require("when").promise;

  schemes = {
    http: require("http"),
    https: require("https")
  };

  _ref = require("fairmont"), read = _ref.read, type = _ref.type;

  user_agent = "Shred version 1.0";

  redirects = [301, 302, 303, 305, 307];

  counter = 0;

  request = function(_arg, body) {
    var expect, headers, id, method, redirect, stream, url;
    url = _arg.url, method = _arg.method, headers = _arg.headers, redirect = _arg.redirect, stream = _arg.stream, expect = _arg.expect;
    id = ++counter;
    if (redirect == null) {
      redirect = true;
    }
    if (headers["user-agent"] == null) {
      headers["user-agent"] = user_agent;
    }
    if (type(expect) !== "array") {
      expect = [expect];
    }
    if (body != null) {
      if (type(body) !== "string") {
        body = JSON.stringify(body);
      }
    }
    return promise(function(resolve, reject) {
      var handler, hostname, path, port, protocol, readBody, scheme, _ref1;
      handler = function(response) {
        var data, statusCode, _error, _ref1, _ref2;
        data = readBody(response);
        if (_ref1 = response.statusCode, __indexOf.call(expect, _ref1) >= 0) {
          return resolve({
            response: response,
            data: data
          });
        } else if ((_ref2 = response.statusCode, __indexOf.call(redirects, _ref2) >= 0) && redirect === true) {
          return request(response.headers.location);
        } else {
          statusCode = response.statusCode;
          _error = new Error("Expected " + expect + ", got " + statusCode);
          _error.context = {
            response: response,
            data: data
          };
          return reject(_error);
        }
      };
      readBody = function(response) {
        var transform, zlib;
        if (stream != null) {
          transform = (function() {
            switch (response.headers["content-encoding"]) {
              case 'gzip':
                zlib = require("zlib");
                return response.pipe(zlib.createGunzip());
              case 'deflate':
                zlib = require("zlib");
                return response.pipe(zlib.createInflate());
              default:
                return response;
            }
          })();
          return transform.pipe(stream);
        } else {
          return promise(function(resolve, reject) {
            body = "";
            response.on("data", function(data) {
              return body += data;
            });
            return response.on("end", function() {
              var _ref1;
              if ((_ref1 = response.headers["content-type"]) != null ? _ref1.match(/json/) : void 0) {
                return resolve(JSON.parse(body));
              } else {
                return resolve(body);
              }
            });
          });
        }
      };
      _ref1 = parse_url(url), protocol = _ref1.protocol, hostname = _ref1.hostname, port = _ref1.port, path = _ref1.path;
      scheme = protocol.slice(0, -1);
      return schemes[scheme].request({
        hostname: hostname,
        port: port || (scheme === 'https' ? 443 : 80),
        path: path,
        method: method.toUpperCase(),
        headers: headers
      }).on("response", handler).on("error", function(error) {
        return reject(error);
      }).end(body);
    });
  };

  module.exports = {
    request: request
  };

}).call(this);
